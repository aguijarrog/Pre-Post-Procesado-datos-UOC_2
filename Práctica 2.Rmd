---
title: "Tipología y ciclo de vida de los datos: Práctica 2 - Pre-Post Procesado de datos"
author: "Alejandro Guijarro - Sergio Roque Duarte Pérez"
date: "10/5/2020"
output: 
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: true
    toc_depth: 5
    toc_float:
      collapsed: false
      smooth_scroll: true
    includes:
      in_header: header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```
******
# Introducción y Contexto
******

El presente documento recoge las respuestas a los puntos recogidos en la Práctica 2 de la asignatura Tipología y Ciclo de Vida de los Datos. El informe se ha elaborado siguiendo la estructura propuesta en el enunciado de la práctica.

Se ha optado en esta segunda práctica por continuar con el tema desarrollado en la práctica 1, centrada en la extracción de datos relacionados con el virus COVID-19.
Se toma para ello como punto de partida la estructura para extracción de datos generada en la Práctica 1.

Los entornos web seleccionados para la extracción de los datos citados son:

•	https://www.worldometers.info/coronavirus/: estadísticas de individuos infectados.

•	https://www.ree.es/es: datos de consumo eléctrico (proporcionados por Red Eléctrica) en España.

•	https://covid19.isciii.es/: estadísticos sobre la evolución de los casos de COVID-19 por CCAA.

El objetivo de dicho estudio es el de evaluar el impacto de la propagación del virus COVID-19 en el consumo energético. Se plantea dicho estudio a partir del análisis de los datos disponibles de propagación y afectados por el virus, junto con los registros de consumo energético en España.

## Descripción del Dataset

Se muestra a continuación una breve descripción de los dataset obtenidos en la Práctica 1, utilizados en esta segunda práctica para el desarrollo de la misma.

### Consumo_elect_COVID_2020 & Consumo elect_COVID_2019

Registro con los datos de consumo energético en España para los meses de enero, febrero, marzo, abril, en años 2019 y 2020.

Ev_demanda20:dataset incluyendo datos de demanda eléctrica diaria entre meses de enero-febrero-marzo-abril 2020. Datos exportados en fichero .csv Consumo_elect_COVID_2020.csv.

Ev_demanda2019:dataset incluyendo datos de demanda eléctrica diaria entre meses de enero-febrero-marzo-abril 2019. Datos exportados en fichero .csv Consumo_elect_COVID_2019.csv.

Generación de ambos dataset mediante la ejecución del script “API - Red Electrica.py”

Importamos los datasets.
```{r }
elect_2020<-read.csv2("Consumo_elect_COVID_2020.csv",header=T,stringsAsFactors=FALSE, fileEncoding="latin1",sep=",",dec=".")

elect_2019<-read.csv2("Consumo_elect_COVID_2019.csv",header=T,stringsAsFactors=FALSE, fileEncoding="latin1",sep=",",dec=".")
```

### Casos_COVID_ESPAÑA


Registro de datos de coronavirus en España y agrupados por CCAA (CCAA), fecha de los registros (FECHA), número de casos totales (CASOS), número de test positivos para los anticuerpos (TestAc+), número de personas hospitalizadas (Hospitalizados), personas ingresadas en UCI (UCI), número de fallecidos (Fallecidos) y número de recuperados (Recuperados). 

Los datos son exportados al fichero “Casos_COVID_ESPAÑA.csv” tras la descarga de la web del ministerio de sanidad https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos. Recordamos la imposibilidad de obtener estos datos por errores sin solución de la práctica anterior y que no se pueden obtener de otra forma. 


Importamos el dataset.
```{r message= FALSE, warning=FALSE}
covid_espana<-read.csv("Casos_COVID_ESPAÑA.csv",header=T,sep=",", stringsAsFactors=FALSE)
attach(covid_espana)

```



# Integración y Selección de los datos de interés a analizar

## Datos consumo energético

Extraídos a partir de la aplicación API disponible en la plataforma REData de Red Eléctrica: https://www.ree.es/es, 
El conjunto de datos seleccionado mediante la request lanzada a la API se ha limitado a la evolución de la demanda para los meses de enero-febrero-marzo-abril. 

r = requests.get('https://apidatos.ree.es/es/datos/demanda/
indicamos los datos, en este caso evolución de demanda
  evolucion?
rango temporal para el que solicitamos los datos
  start_date=2020-01-01T00:00&end_date=2020-0325T22:00&
fracción temporal en la que queremos visualizar los datos (diario)
  time_trunc=day&
Zona geográfica sobre la que aplicaremos la extracción de datos.
  geo_limit=peninsular&
  geo_ids=8741')

## Evolución COVID-19 en España

En cuanto a la evolución de los datos sobre los casos del COVID-19 por comunidades autónomas, obtenemos un dataset de la web https://cnecovid.isciii.es/ mediante descarga directa. El archivo contiene los datos acumulados de la evolución de los casos para las variables descritas en el apartado anterior. Estos se encuentran ordenados por comunidad autónoma y los registros parten desde el 20 de febrero de 2020 hasta el 17 de mayo del 2020 (actualidad).

# Limpieza de los datos

## Ceros Elementos Vacíos

En cuanto al tratamiento de elementos vacíos, se plantea en este apartado un barrido de los dataframes que se analizarán posteriormente a fin de identificar, o descartar la presencia de dichos elementos vacíos que puedan repercutir negativamente en la interpretación y tratamiento de los datos.

```{r }
NA_Noff_elect2020 <-sapply(elect_2020, function(y) sum(length(which(is.na(y))))) #count de campos NA para cada variable en el dataframe
NA_Noff_elect2020 <- data.frame(NA_Noff_elect2020) #generamos un dataframe para la visualización del total de NA "valores perdidos" por variable

NA_Noff_elect2019 <-sapply(elect_2019, function(y) sum(length(which(is.na(y))))) #count de campos NA para cada variable en el dataframe
NA_Noff_elect2019 <- data.frame(NA_Noff_elect2019) #generamos un dataframe para la visualización del total de NA "valores perdidos" por variable
```


Se presenta a continuación el resultado del preprocesado de los dataframes para identificación de elementos vacíos.
```{r }
NA_Noff_elect2020
NA_Noff_elect2019
```

Vemos como estos dos dataframes no contienen en ningún caso elementos vacíos --> debido a como se ha podido extraer la información de los entornos web.

Sin embargo, no ocurre lo mismo para el DataFrame de los casos de COVID-19.

Para el conjunto de datos de los casos de COVID-19 se propone una metodología diferente a la de los datos de la API. 

Primero lo que haremos es comprobar la presencia de valores vacios mediante el uso de la función summary() de las expresiones regulares de R.

```{r}
summary(covid_espana)
```

Como se puede observar, y como era de esperar ya que los datos son de tipo acumulado, hay una gran cantidad de valores NA. Para este estudio en concreto se plantea la sustitución de esos valores nulos por ceros ya que no representa ningún problema para el análisis. 

Antes de sustituir los valores NAN, haremos una selección de las variables que realmente vamos a utilizar en el análisis.

```{r echo=TRUE, message=FALSE, warning=FALSE}


if(!require(dplyr)){
    install.packages('dplyr', repos='http://cran.us.r-project.org')
    library(dplyr)
}
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Llamada a la librería necesaria para seleccionar columnas
library(dplyr)

# Filtraremos el DataFrame para evaluar solo las variables que nos interesan
covid_espana <- select(covid_espana,CCAA,FECHA, PCR.)

```

Volvemos a comprobar los valores perdidos:

```{r}
summary(covid_espana)
```
Como solo hay presencia de valores NaN en la variable de las PCR positivas, que además es la variable que más nos interesa para el análisis, sustituiremos esos valores perdidos por 0s.


```{r}
# Sustitución de valores NaN por ceros
covid_espana$PCR.[is.na(covid_espana$PCR.)] <- 0
```

Una vez hecho esto comprobaremos por última vez que ahora este dataset no presenta valores NAN:

```{r}
summary(covid_espana)
```



<span style="color:red"> *ALEJANDRO, Está corregido lo que fallaba hasta aquí. Seguimos manteniendo la aplicación del KNN que propones?*</span>

mostrar algo de planteamiento de cómo se habrían tratado un dataframe en case de identificar elementos nulos --> identificación de datos y elminicación de los rows correspondientes - Imputación mediante métodos probabilísticos (kNN nearest neighbo)

Aplicamos la función "kNN" a las variables "BPD" y "AD", con un k=3:
```{r ,eval=FALSE}
#library("VIM")
#dataframe=kNN(df,variable=c("A","B"),k=3)
```


## Identificación y tratamiento de valores extremos

Para la identificación de valores extremos en los dataframes objeto del análisis, procedemos a la presentación de los datos mediante un diagrama de cajas para la variable en cuestión.

**elect_2019**
```{r }
boxplot.stats(elect_2019$ev_demanda)$out
```
```{r , echo=FALSE}
boxplot(elect_2019$ev_demanda,main="graph - ev_demanda2019")
```
**elect_2020**
```{r }
boxplot.stats(elect_2020$ev_demanda)$out
```
```{r , echo=FALSE}
boxplot(elect_2020$ev_demanda,main="graph - ev_demanda2020")
```


**Casos_COVID_ESPAÑA**

```{r }
boxplot.stats(covid_espana$PCR.)$out
```
```{r , echo=FALSE}
boxplot(covid_espana$PCR.,main="graph - Casos_COVID_ESPAÑA")
```

<span style="color:red"> *ALEJANDRO, en cuanto al boxplot me parece normal que muestre tantos valores extremos ya que es un dataframe de casos acumulados . No se si dejarlo así explicado o eliminarlo. ¿Como lo ves?*</span>

Como se aprecia en el Boxplot de los casos acumulados del COVID por comunidades autónomas, existe una gran cantidad de valores extremos. Sin embargo, esto no quiere decir que se deban corregir, de hecho es bastante lógico que aparezcan por la gran cantidad de ceros que se encuentran en los primeros registros del DataFrame.

<span style="color:red"> *ALEJANDRO, no se si existen métodos alternativos para evaluar la presencia de valores extremos en esta clase de datasets. No he cursado estadística y la que estudié en la carrera la tengo algo oxidada. *</span>

# Análisis de los datos

## Selección de los grupos de datos

Para la evaluación de los dataset con el registro de demanda energética, estaremos interesados en mostrar una comparativa de la evolución de dicha demanda a fin de identificar varaciaciones significativas entre 2020 y 2019. 

Una de las primera particularidades que vemos es que el año 2019 es bisiesto, conteniendo un día más que puede dar lugar a errores en el desarrollo de dicha comparativa. Procederemos a eliminar el registro correspondiente al año 2020 (mes-febrero, día-29), y tener de esta forma dos dataframes lo más homogéneos posible y con un mismo número de registros.

```{r }
subset(elect_2020, day==29 & month==2)
```

Identificado la fila que contiene los datos correspondientes al mes de febrero (día 29), del 2020, procedemos a eliminar dicho registro y generar un único dataframe que contenga los registros de ambos años, 2020 y 2019, y que nos permita llevar a cabo los posteriores estudios.

```{r }
elect_2020_feb=elect_2020[-c(60),] #eliminamos registro del año bisiesto.
rownames(elect_2020_feb)=NULL #redefinimos indices en dataframe 
elect=elect_2020_feb #generamos dataframe elect con datos de demanda para años 2020 y 2019
colnames(elect)[colnames(elect)=="ev_demanda"]="ev_demanda_2020"
elect$ev_demanda2019=elect_2019$ev_demanda
drop=names(elect) %in% c("date")
elect=elect[,!drop]
```

<span style="color:red"> *ALEJANDRO, no me salen las agrupaciones por meses... No se si es saturación o mi inexperiencia en R pero no doy con la tecla. Le he dado 15000 vueltas y me tiene negro ya xD* normal</span>

En cuanto al DataFrame de los casos de COVID positivos lo que se hará es agrupar los casos según el mes y CCAA para poder compararlos con los plots del consumo eléctrico.


```{r}
covid_espana %>%

  mutate(month = format(as.Date(covid_espana$FECHA, "%d/%M/%Y"), "%M"))%>%
  group_by(month, CCAA) %>%
  summarise(Total = sum(PCR.))

covid_espana
```

## Comprobación de normalidad y homogeneidad de la varianza

<span style="color:red"> *SERGIO y Alejandro, pendiente darle una vuelta a ver que test aplicamos para comprobación de normalidad-homogeneidad*</span>

## Pruebas Estadísticas

<span style="color:red"> *SERGIO y Alejandro*</span>

Cosas a revisar

- Regresión logística
$Ev_demanda(afectados covid)$
threshold, demanda baja (por debajo de la media de 2019)

- Regresión lineal
$Ev_demanda(afectados covid)$

- Contraste de hipótesis??

# Representación de los resultados

**Evolución demanda 2019-2020**
```{r , warning=FALSE}
plot(elect$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
elect_jan=elect[elect$month==1,]
elect_feb=elect[elect$month==2,]
elect_mar=elect[elect$month==3,]
elect_apr=elect[elect$month==4,]
```


**Evolución demanda 2019-2020 (Enero)**
```{r , warning=FALSE}
plot(elect_jan$day, elect_jan$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (January)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_jan$day, elect_jan$ev_demanda2019,type="overplotted",pch=2,col="red")

legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```


**Evolución demanda 2019-2020 (Febrero)**
```{r , warning=FALSE}
plot(elect_feb$day, elect_feb$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (February)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_feb$day, elect_feb$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```


**Evolución demanda 2019-2020 (Marzo)**
```{r , warning=FALSE}
plot(elect_mar$day, elect_mar$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (March)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_mar$day, elect_mar$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```

**Evolución demanda 2019-2020 (Abril)**
```{r , warning=FALSE}
plot(elect_apr$day, elect_apr$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (April)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_apr$day, elect_apr$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```

<span style="color:red"> *ALEJANDRO, no me salen los plot y me imagino que es porque no consigo agrupar las PCR por fecha *</span>

```{r}
library(ggplot2)
ggplot(covid_espana, aes(x=FECHA, y=PCR., group = CCAA, colour =CCAA )) + 
  geom_line()  + 
  geom_point( size=2, shape=70, fill="white") + 
  theme_minimal()
```


# 6. Resolución del problema

<span style="color:red"> *SERGIO y Alejandro*</span>



