---
title: "Tipología y ciclo de vida de los datos: Práctica 2 - Pre-Post Procesado de datos"
author: "Alejandro Guijarro - Sergio Roque Duarte Pérez"
date: "10/5/2020"
output: 
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: true
    toc_depth: 5
    toc_float:
      collapsed: false
      smooth_scroll: true
    includes:
      in_header: header.html
  word_document: default
  pdf_document:
    highlight: zenburn
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
******
# Introducción y Contexto
******

El presente documento recoge las respuestas a los puntos recogidos en la Práctica 2 de la asignatura Tipología y Ciclo de Vida de los Datos. El informe se ha elaborado siguiendo la estructura propuesta en el enunciado de la práctica.

Se ha optado en esta segunda práctica por continuar con el tema desarrollado en la Práctica 1 de la asignatura, centrada en la extracción de datos relacionados con el virus COVID-19.
Se toma para ello como punto de partida la estructura para extracción de datos generada en la Práctica 1.

Los entornos web seleccionados para la extracción de los datos citados son:

•	https://www.worldometers.info/coronavirus/: estadísticas de individuos infectados.

•	https://www.ree.es/es: datos de consumo eléctrico (proporcionados por Red Eléctrica) en España.

•	https://covid19.isciii.es/: estadísticos sobre la evolución de los casos de COVID-19 por CCAA.

El objetivo de dicho estudio es el de evaluar el impacto de la propagación del virus COVID-19 en el consumo energético. Se plantea dicho estudio a partir del análisis de los datos disponibles de propagación y afectados por el virus, junto con los registros de consumo energético en España.

## Descripción del Dataset

Se muestra a continuación una breve descripción de los dataset obtenidos en la Práctica 1, utilizados en esta segunda práctica para el desarrollo de la misma.

### Consumo_elect_COVID_2020 & Consumo elect_COVID_2019

Registro con los datos de consumo energético en España para los meses de enero, febrero, marzo, abril, en años 2019 y 2020.

**Ev_demanda20:**dataset incluyendo datos de demanda eléctrica diaria entre meses de enero-febrero-marzo-abril 2020. Datos exportados en fichero .csv *Consumo_elect_COVID_2020.csv*.

**Ev_demanda2019:**dataset incluyendo datos de demanda eléctrica diaria entre meses de enero-febrero-marzo-abril 2019. Datos exportados en fichero .csv *Consumo_elect_COVID_2019.csv*.

Generación de ambos dataset mediante la ejecución del script *API - Red Electrica.py*.

Importamos los datasets.
```{r }
elect_2020<-read.csv2("Consumo_elect_COVID_2020.csv",header=T,stringsAsFactors=FALSE, fileEncoding="latin1",sep=",",dec=".")
elect_2019<-read.csv2("Consumo_elect_COVID_2019.csv",header=T,stringsAsFactors=FALSE, fileEncoding="latin1",sep=",",dec=".")
```



### Casos_COVID_ESPAÑA


Registro de datos de coronavirus en España y agrupados por CCAA (CCAA), fecha de los registros (FECHA), número de casos totales (CASOS), número de test positivos para los anticuerpos (TestAc+), número de personas hospitalizadas (Hospitalizados), personas ingresadas en UCI (UCI), número de fallecidos (Fallecidos) y número de recuperados (Recuperados). 

Los datos son exportados al fichero *Casos_COVID_ESPAÑA.csv* tras la descarga de la web del ministerio de sanidad https://cnecovid.isciii.es/covid19/#documentaci%C3%B3n-y-datos. Recordamos la imposibilidad de obtener estos datos por errores sin solución de la práctica anterior y que no se pueden obtener de otra forma. 


Importamos el dataset.
```{r message= FALSE, warning=FALSE}
covid_espana<-read.csv("Casos_COVID_ESPAÑA.csv",header=T,sep=",", stringsAsFactors=FALSE)
attach(covid_espana)
```

<span style="color:red"> *Alejandro, he añadido este apartado para los 3 sets. Revísalo por si crees que hay que cambiar algo, sobre todo de los tuyos*</span>

### Análisis preliminar de los datasets

Una vez que hemos importado todos los dataset de la API y los caso de COVID-19, haremos uso de algunas funciones regulares de R para obtener una primera aproximación a la estructura de los datos de cada uno de los conjuntos.


- Ev_demanda20 y Ev_demanda2019: para estos dos datasets haremos uso de las funciones summary() y str()

```{r}
str(elect_2019)
```

El uso de str() permite un primer contacto con la estructura del set, como en este caso, podemos observar variables de tipo int, num y str y ninguna de tipo discreto.

```{r}
summary(elect_2020)

```

Y el uso de summary() muestra un análisis de los estadisticos básicos del set que resulta de gran ayuda antes de continuar con los siguientes procesos.


- COVID-19: para el caso de este dataset haremos uso de las funciones head() y tail()

```{r}
head(covid_espana)
tail(covid_espana)
```

Como era de esperar (ya que los datos en este DataFrame están dispuestos de manera acumulativa), vemos que los primeros registros de este dataset presentan numerosos valores NaN y valores = 0. En cuanto a la cola, observamos la presencia de los registros con los valores más altos de PCRs y demás variables para cada CCAA.


# Integración y Selección de los datos de interés a analizar

## Datos consumo energético

Extraídos a partir de la aplicación API disponible en la plataforma REData de Red Eléctrica: https://www.ree.es/es.

El conjunto de datos seleccionado mediante la request lanzada a la API se ha limitado a la evolución de la demanda para los meses de enero-febrero-marzo-abril en años 2019 y 2020.

r = requests.get(https://apidatos.ree.es/es/datos/demanda/
*indicamos los datos, en este caso evolución de demanda*
  **evolucion?**
*rango temporal para el que solicitamos los datos*
  **start_date=2020-01-01T00:00&end_date=2020-0325T22:00**&
*fracción temporal en la que queremos visualizar los datos (diario)*
  **time_trunc=day**&
*Zona geográfica sobre la que aplicaremos la extracción de datos.*
  **geo_limit=peninsular**&
  **geo_ids=8741'**)

## Evolución COVID-19 en España

En cuanto a la evolución de los datos sobre los casos del COVID-19 por comunidades autónomas, obtenemos un dataset de la web https://cnecovid.isciii.es/ mediante descarga directa. El archivo contiene los datos acumulados de la evolución de los casos para las variables descritas en el apartado anterior. Estos se encuentran ordenados por comunidad autónoma y los registros parten desde el 20 de febrero de 2020 hasta el 17 de mayo del 2020 (actualidad).

# Limpieza de los datos

## Ceros Elementos Vacíos

En cuanto al tratamiento de elementos vacíos, se plantea en este apartado un barrido de los dataframes que se analizarán posteriormente a fin de identificar, o descartar la presencia de dichos elementos vacíos que puedan repercutir negativamente en la interpretación y tratamiento de los datos.

**Dataframes: elect2020 & elect 2019**

```{r }
NA_Noff_elect2020 <-sapply(elect_2020, function(y) sum(length(which(is.na(y))))) #count de campos NA para cada variable en el dataframe
NA_Noff_elect2020 <- data.frame(NA_Noff_elect2020) #generamos un dataframe para la visualización del total de NA "valores perdidos" por variable
NA_Noff_elect2019 <-sapply(elect_2019, function(y) sum(length(which(is.na(y))))) #count de campos NA para cada variable en el dataframe
NA_Noff_elect2019 <- data.frame(NA_Noff_elect2019) #generamos un dataframe para la visualización del total de NA "valores perdidos" por variable
```


Se presenta a continuación el resultado del preprocesado de los dataframes para identificación de elementos vacíos.
```{r }
NA_Noff_elect2020
NA_Noff_elect2019
```

Vemos como estos dos dataframes no contienen en ningún caso elementos vacíos, la extracción de la información del entorno web para ambos dataframes se ha llevado a cabo sin NA´s resultantes.

**Dataframes: covid_espana**

Procedemos a continuación a revisar el dataframe que contiene los casos de COVID-19. Se propone para ello una metodología ligeramente diferente a la mostrada para los datos de demanda eléctrica. 

Primero lo que haremos es comprobar la presencia de valores vacios mediante el uso de la función summary() de las expresiones regulares de R, así como el uso de str() que nos dará información sobre que tipo de variables se encuentra en este set.

```{r}
summary(covid_espana)
str(covid_espana)
```

<span style="color:red"> *Alejandro, mira si te parece bien esta justificación de los valores nulos, sobre todo a la redacción. Creo qu está bien pero si ves cualquier cosa cambialo sin problema*</span>

Para este estudio en concreto se plantea la sustitución de valores nulos por ceros.

Con lo visto en el apartado anterior, este set de datos acumulados presenta al inicio un gran número de registros de tipo NaN y esto es debido a que no existían casos positivos de COVID-19 en muchas de las CCAA de España. Además, al llamar a la función tail() hemos comprobado que al final del DataFrame no nos encontrabamos con ningún registro con valores perdidos y que al analizar el set con la función str, vemos que los valores NaN solo afectan a las variables de tipo int. Otra razón que nos lleva a tomar esta decisión es la propia naturaleza del set y es que en los casos de datos dispuestos de forma acumulativa, los primeros registros son siempre los más bajos o nulos. Por todo lo anterior, asumiremos que la sustitución de los mismos por 0s no supondrá error alguno en los análisis ni las representaciones gráficas posteriores.

Antes de sustituir los valores NAN, haremos una selección de las variables que realmente vamos a utilizar en el análisis.

```{r echo=TRUE, message=FALSE, warning=FALSE}
if(!require(dplyr)){
    install.packages('dplyr', repos='http://cran.us.r-project.org')
    library(dplyr)
}
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
# Llamada a la librería necesaria para seleccionar columnas
library(dplyr)
# Filtraremos el DataFrame para evaluar solo las variables que nos interesan
covid_espana <- select(covid_espana,CCAA,FECHA, PCR.)
```

Volvemos a comprobar los valores perdidos:

```{r}
summary(covid_espana)
```
Entre las varables seleccionadas de interés para el análisis, vemos que unicamente identificamos la presencia de valores NaN en la variable de las PCR positivas.

Procedemos con la sustitución de NANs por 0s.


```{r}
# Sustitución de valores NaN por ceros
covid_espana$PCR.[is.na(covid_espana$PCR.)] <- 0
```

Una vez hecho esto comprobaremos por última vez que ahora este dataset no presenta valores NAN:

```{r}
summary(covid_espana)
```




## Identificación y tratamiento de valores extremos

Para la identificación de valores extremos en los dataframes objeto del análisis, procedemos a la presentación de los datos mediante un diagrama de cajas para la variable en cuestión.

**elect_2019**
```{r }
boxplot.stats(elect_2019$ev_demanda)$out
```
```{r , echo=FALSE}
boxplot(elect_2019$ev_demanda,main="graph - ev_demanda2019")
```
**elect_2020**
```{r }
boxplot.stats(elect_2020$ev_demanda)$out
```
```{r , echo=FALSE}
boxplot(elect_2020$ev_demanda,main="graph - ev_demanda2020")
```


**Casos_COVID_ESPAÑA**

```{r }
boxplot.stats(covid_espana$PCR.)$out
```
```{r , echo=FALSE}
boxplot(covid_espana$PCR.,main="graph - Casos_COVID_ESPAÑA")
```


Como se aprecia en el Boxplot de los casos acumulados del COVID por comunidades autónomas, existe una gran cantidad de valores extremos. Sin embargo, esto no quiere decir que se deban corregir, de hecho es bastante lógico que aparezcan por la gran cantidad de ceros que se encuentran en los primeros registros del DataFrame.

# Análisis de los datos
## Selección de los grupos de datos
Para la evaluación de los dataset con el registro de demanda energética, estaremos interesados en mostrar una comparativa de la evolución de dicha demanda a fin de identificar varaciaciones significativas entre 2020 y 2019. 

Una de las primera particularidades que vemos es que el año 2019 es bisiesto, conteniendo un día más que puede dar lugar a errores en el desarrollo de dicha comparativa. Procederemos a eliminar el registro correspondiente al año 2020 (mes-febrero, día-29), y tener de esta forma dos dataframes lo más homogéneos posible y con un mismo número de registros.

```{r }
subset(elect_2020, day==29 & month==2)
```

Identificada la fila que contiene los datos,  procedemos a eliminar dicho registro y combinar los datos de años 2019 y 2020 en un único dataframe.

```{r }
elect_2020_feb=elect_2020[-c(60),] #eliminamos registro del año bisiesto.
rownames(elect_2020_feb)=NULL #redefinimos indices en dataframe 
elect=elect_2020_feb #generamos dataframe elect con datos de demanda para años 2020 y 2019
colnames(elect)[colnames(elect)=="ev_demanda"]="ev_demanda_2020"
elect$ev_demanda2019=elect_2019$ev_demanda
drop=names(elect) %in% c("date")
elect=elect[,!drop]
```


En cuanto al DataFrame de los casos de COVID positivos lo que se hará es agrupar los casos según el mes y CCAA para poder compararlos con los plots del consumo eléctrico.


```{r }
library(lubridate) #librería para uso de la función month

covid_espana$FECHAaux=dmy(covid_espana$FECHA) #conversión FECHA al formado correcto "/" --> "-"
covid_espana$month=month(covid_espana$FECHAaux) #generamos columna con meses
covid_espana$day=day(covid_espana$FECHAaux) #generamos columna con días
```



## Comprobación de normalidad y homogeneidad de la varianza

<span style="color:red"> *Alejandro, SI PUDIERAS AÑADIR ALGUNA CONCLUSIÓN A ESTE APARTADO SERÍA MEJOR QUE LA QUE PUEDO APORTAR YO, YA QUE HAS CURSADO ESTADÍSTICA*</span>

Para el estudio de la normalidad de los datos, haremos uso de varias librerias que se cargan a continuación.

```{r echo=TRUE, message=FALSE, warning=FALSE}
if(!require(normtest)){
    install.packages('normtest', repos='http://cran.us.r-project.org')
    library(normtest)
}

```

```{r}
library(normtest) #CON ESTA LIBRERÍA SE PUEDEN REALIZAR 5 PRUEBAS DE NORMALIDAD
```

Procedemos a crear los subconjuntos de datos para algunas de las CCAA más afectadas (Para los DataSets del consumo eléctrico no es necesario crear esos subconjuntos):

```{r}
#Crear sub-conjunto de datos
AN <-subset(covid_espana,CCAA=="AN") #cuando se tiene la muestra de varios grupos es apropiado comprobar la normalidad por grupo.

CB <- subset(covid_espana,CCAA=="CB")
CM <- subset(covid_espana,CCAA=="CM")

```

- Hipótesis

H0: La muestra proviene de una distribución normal.

H1: La muestra no proviene de una distribución normal.

Para pruebas de normalidad siempre se plantean así las hipótesis.

- Nivel de Significancia

El nivel de significancia que se trabajará es de 0.05. Alfa=0.05

Criterio de Decisión

Si P < Alfa Se rechaza Ho

Si p >= Alfa No se rechaza Ho

Histogramas para los subconjuntos creados y para los sets del consumo eléctrico:
```{r}
#Histogramas COVID
hist(AN[,4])
hist(CB[,4])
hist(CM[,4])

#Histogramas EV
hist(elect_2019[,2])
hist(elect_2020[,2])
```

Pruebas de normalidad:
```{r}
#Prueba de Anderson-Darling
ad.test(AN[,4])
ad.test(CB[,4])
ad.test(CM[,4])

ad.test(elect_2019[,2])
ad.test(elect_2020[,2])
```



```{r}
#Prueba de Cramer-von Mises
cvm.test(AN[,4])
cvm.test(CB[,4])
cvm.test(CM[,4])

cvm.test(elect_2019[,2])
cvm.test(elect_2020[,2])
```
```{r}
# Prueba de Pearson (Chi cuadrado)
pearson.test(AN[,4])
pearson.test(CB[,4])
pearson.test(CM[,4])

pearson.test(elect_2019[,2])
pearson.test(elect_2020[,2])
```
## Pruebas Estadísticas

<span style="color:red"> *SERGIO y Alejandro*</span>

Para realizar las pruebas estadísticas optaremos por dividir el conjunto de datos en un conjunto de entrenamiento y un conjunto de prueba. El conjunto de entrenamiento es el subconjunto del conjunto original de datos utilizado para construir un primer modelo; y el conjunto de prueba, el subconjunto del conjunto original de datos utilizado para evaluar la calidad del modelo. 

Lo más correcto será utilizar un conjunto de datos diferente del que utilizamos para construir el árbol, es decir, un conjunto diferente del de entrenamiento. No hay ninguna proporción fijada con respecto al número relativo de componentes de cada subconjunto, pero la más utilizada acostumbra a ser 2/3 para el conjunto de entrenamiento y 1/3, para el conjunto de prueba.

Como hemos podido comprobar con anterioridad, nuestros conjuntos de datos se encontraban ordenados. Para realizar este tipo de prubas estadísticas, nos interesará que los mismos se encuentren desordenados. Para ello procederemos a guardarlos en unos nuevos sets con el prefijo random_.

```{r}
# Desordenamos los sets
set.seed(1)
random_covid <- covid_espana[sample(nrow(covid_espana)),]

random_elec_2019 <- elect_2019[sample(nrow(elect_2019)),]
random_elec_2020 <- elect_2020[sample(nrow(elect_2020)),]
```


La variable con la que clasificaremos el conjunto de datos del random_covid será la de las PCR que se encuentra en la columna 4 y para los sets del consumo eléctrico usaremos la ev_demanda que se encuentra en la posicion 2.

<span style="color:red"> *Alejandro dale una vuelta a la parte de tus sets que no se muy bien como organizarlo*</span>

```{r}
set.seed(666)
covid_y <- random_covid[,4] 
covid_X <- random_covid[,6:9] 

```

Podemos elegir el subconjunto de entrenamiento y de prueba de diversas maneras. La primer opción consiste en calcular a cuántas filas corresponde dos tercios de los datos (2*1680/3=1120) y dividir "manualmente" el conjunto.

```{r}
trainX <- covid_X[1:1120,]
trainy <- covid_y[1:1120]
testX <- covid_X[1120:1680,]
testy <- covid_y[1120:1680]
```

En la segunda opción podemos crear directamente un rango.

```{r}
indexes = sample(1:nrow(random_covid), size=floor((2/3)*nrow(random_covid)))
trainX<-covid_X[indexes,]
trainy<-covid_y[indexes]
testX<-covid_X[-indexes,]
testy<-covid_y[-indexes]
```


Después de una extracción aleatoria de casos es altamente recomendable efectuar un análisis de datos mínimo para asegurarnos de no obtener clasificadores sesgados por los valores que contiene cada muestra. 


<span style="color:red"> *Alejandro mira a ver si puedes dar con el error que me arrojan las siguientes lineas*</span>

Se crea el árbol de decisión usando los datos de entrenamiento:

```{r}
model <- C50::C5.0(trainX, trainy,rules=TRUE )
summary(model)
```

Cosas a revisar

- Regresión logística
$Ev_demanda(afectados covid)$
threshold, demanda baja (por debajo de la media de 2019)

- Regresión lineal
$Ev_demanda(afectados covid)$

- Contraste de hipótesis??

# Representación de los resultados

**Evolución demanda 2019-2020**
```{r , warning=FALSE}
plot(elect$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))

#particionamos el dataframe para el posterior tratamiento de los resultados por mes.
elect_jan=elect[elect$month==1,]
elect_feb=elect[elect$month==2,]
elect_mar=elect[elect$month==3,]
elect_apr=elect[elect$month==4,]
```


**Evolución demanda 2019-2020 (Enero)**
```{r , warning=FALSE}
plot(elect_jan$day, elect_jan$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (January)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_jan$day, elect_jan$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```


**Evolución demanda 2019-2020 (Febrero)**
```{r , warning=FALSE}
plot(elect_feb$day, elect_feb$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (February)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_feb$day, elect_feb$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```


**Evolución demanda 2019-2020 (Marzo)**
```{r , warning=FALSE}
plot(elect_mar$day, elect_mar$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (March)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_mar$day, elect_mar$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```

**Evolución demanda 2019-2020 (Abril)**
```{r , warning=FALSE}
plot(elect_apr$day, elect_apr$ev_demanda_2020, type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="ev-demanda",   main="Ev-demanda (April)", ylim=c(min(elect$ev_demanda_2020), max(elect$ev_demanda2019)))
lines(elect_apr$day, elect_apr$ev_demanda2019,type="overplotted",pch=2,col="red")
legend("topright",legend=c("2020","2019"),    pch=c(1,2),col=c("blue","red"))
```


**Evolución Covid - Acumulado (MD-CT-PV)**
```{r , warning=FALSE}
plot(covid_espana$PCR., type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="Test PCR",   main="Casos Covid (PCR)", ylim=c(min(covid_espana$PCR), max(covid_espana$PCR)))
legend("topleft",legend="acumulado",    pch=c(1,2),col=c("blue"))
```
**Evolución Covid - Acumulado **
Representación de los resultados para un mejor entendimiento de los datos, limitado a Comunidad de MAdrid (MD), Cataluña (CT) y País Vasco (PV).

```{r , warning=FALSE}
plot(covid_espana$PCR.[CCAA=="MD"], type="overplotted",   pch=1, col="blue", xlab="Days",    ylab="Test PCR",   main="Casos Covid (PCR)", ylim=c(min(covid_espana$PCR), max(covid_espana$PCR)))
lines(covid_espana$PCR.[CCAA=="CT"],type="overplotted",pch=2,col="red")
lines(covid_espana$PCR.[CCAA=="PV"],type="overplotted",pch=2,col="green")
legend("topleft",legend=c("MD","CT","PV"),    pch=c(1,2),col=c("blue","red","green"))

#particionamos el dataframe para un posterior tratamiento de los resultados por mes
covid_espana_feb=covid_espana[covid_espana$month==2,]
covid_espana_mar=covid_espana[covid_espana$month==3,]
covid_espana_apr=covid_espana[covid_espana$month==4,]
covid_espana_may=covid_espana[covid_espana$month==5,]
```



```{r eval=FALSE, include=FALSE}
library(ggplot2)
ggplot(covid_espana_feb, aes(x=FECHA, y=PCR., group = CCAA, colour =CCAA )) +   geom_line()  + 
  geom_point( size=2, shape=70, fill="white") + 
  theme_minimal()
```

# 6. Resolución del problema
<span style="color:red"> *SERGIO y Alejandro*</span>



